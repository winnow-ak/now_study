## redis集群架构
> - 主从模式
> - 哨兵模式
> - Cluster集群
 
### 1.主从复制原理

#### 主从同步原理
 - 当一个从数据库启动时，它会向主数据库发送一个SYNC命令
 - master收到后，在后台保存快照，也就是我们说的RDB持久化，当然保存快照是需要消耗时间的，并且redis是单线程的，在保存快照期间redis收到的命令会缓存起来，快照完成后会将缓存的命令以及快照一起打包发给slave节点，从而保证主从数据库的一致性。
 - 从数据库接受到快照以及缓存的命令后会将这部分数据写入到硬盘上的临时文件当中，写入完成后会用这份文件去替换掉RDB快照文件，当然，这个操作是不会阻塞的，可以继续接收命令执行，具体原因其实就是fork了一个子进程，用子进程去完成了这些功能。
因为不会阻塞，所以，这部分初始化完成后，当主数据库执行了改变数据的命令后，会异步的给slave，这也就是我们说的复制同步阶段，这个阶段会贯穿在整个主从同步的过程中，直到主从同步结束后，复制同步才会终止。

<b> 那么我上文提到的数据不一致的现象又是怎么回事呢？</b>

是因为redis采用了乐观复制的策略:

容忍一定时间内主从数据库的数据是不一致的，但是会保证最终的结果一致。

所以当主从复制发生时，正常情况下的命令都会在主数据库完成，然后直接反回给客户端，这样我们的性能就不会受到影响了，因为这里是主数据库先完成命令，那么就会产生其他问题。

举个例子，假如现在有1个master，6个slave，现在只有两个slave完成了同步，master写了新命令，在master准备将此命令传输给其他slave时，此刻其他的slave断电了，那么就会造成数据不一致的现象发生。

#### 无硬盘复制
我们刚刚说了主从之间是通过RDB快照来交互的，虽然看来逻辑很简单，但是还是会存在一些问题:

- 1.master禁用了RDB快照时，发生了主从同步(复制初始化)操作，也会生成RDB快照，但是之后如果master发成了重启，就会用RDB快照去恢复数据，这份数据可能已经很久了，中间就会丢失数据
- 2.在这种一主多从的结构中，master每次和slave同步数据都要进行一次快照，从而在硬盘中生成RDB文件，会影响性能
为了解决这种问题，redis在后续的更新中也加入了无硬盘复制功能，也就是说直接通过网络发送给slave，避免了和硬盘交互，但是也是有io消耗的。

#### 增量复制
为什么会有增量复制？

刚刚我们说了复制的原理，但是他的缺点是很明显的，就是在断开主从链接后，即使你只发生了一条数据变化，也需要将所有的数据通过SYNC命令用RDB将所有的数据同步给slave，但是其实并不需要同步所有的数据，只需要将改变的这小部分数据同步给slave就好了

所以为了解决这个问题，redis就有了增量复制。

这个原理其实是很简单的，学过kafka 的小伙伴应该知道，kafka消费是通过偏移量来计算的，redis的增量复制也是如此。

master会记下每个slave的id，在复制期间，如果有新消息，会将新消息(其实是新的命令，当然只包括让数据放生变动的命令，如 set  这种 )存放在一个固定大小的循环队列中，这个大小是可以配置的，当然这时候发送的就是PSYNC命令了，然后master会在复制完成后将这部分数据发送给slave，这样就在很大程度上保证了数据一致性。

#### 2.什么是哨兵
顾名思义，哨兵其实就是放哨的，它主要会有完成两个功能。

- 1.监控整个主数据库和从数据库，观察它们是否正常运行

- 2.当主数据库发生异常时，自动的将从数据库升级为主数据库，继续保证整个服务的稳定


#### 实现原理
当一个哨兵进程启动时，它会先通过配置文件，找我们的主数据库，当然，我们这里也只需要配置其监控的主数据库就好，之后哨兵会自动发现所有复制该主数据库的从数据库，当然一个哨兵是可以监控多个redis系统的，
同时，多个哨兵也可以同时监控一个redis系统的，

哨兵进程启动后后会和master建立两条链接

> 1.用来获取其他同样在监控着此redis系统的哨兵信息
> 2.发送一个info命令来获取此redis系统master本身的信息

当和master完成链接建立后，该哨兵就会定时的做以下三件事情

> 1.每10秒会向master和slave发送info命令
> 2.每2秒会向master和slave发送自己的信息
> 3.每1秒会向master，slave以及其他同样在监控着此redis系统的哨兵发送ping命令


#### 哨兵选举过程
- 1.第一个发现该master挂了的哨兵，向每个哨兵发送命令，让对方选举自己成为领头哨兵
- 2.其他哨兵如果没有选举过他人，就会将这一票投给第一个发现该master挂了的哨兵
- 3.第一个发现该master挂了的哨兵如果发现由超过一半哨兵投给自己，并且其数量也超过了设定的quoram参数，那么该哨兵就成了领头哨兵
- 4.如果多个哨兵同时参与这个选举，那么就会重复该过程，知道选出一个领头哨兵
选出领头哨兵后，就开始了故障修复，会从选出一个从数据库作为新的master

#### master选举过程
- 1.从所有在线的从数据库中，选择优先级最高的从数据库
- 2.如果有多个优先级高的从数据库，那么就会判断其偏移量，选择偏移量最小的从数据库，这里的偏移量就是增量复制的
- 3.如果还是有相同条件的从数据库，就会选择运行id较小的从数据库升级为master

### 3.cluster集群模式
在redis3.0版本中支持了cluster集群部署的方式，这种集群部署的方式能自动将数据进行分片，每个master上放一部分数据，提供了内置的高可用服务，即使某个master挂了，服务还可以正常地提供，


### Redis 为什么快
1. 基于内存实现
2. 使用I/O多复用模型，非阻塞I/O
3. 单线程模型，避免不必要上下文切换和竞争条件
4. 高效的数据结构，动态字符串（string）,双向链表（list）、 跳跃表 (sorted set)、 hash 表 、 数组(set)


### Redis hash 字典
redis 整体就是一个哈希表保存所有键值对，无论数据类型是什么，hash表本质就是一个数组，哈希表时间复杂度O(1)

### Redis Hash 冲突怎么办？
Redis 通过`链式哈希解决`冲突：也就是同一个 桶里面的元素使用链表保存。但是当链表过长就会导致查找性能变差可能，所以 Redis 为了追求快，使用了两个全局哈希表。用于 rehash 操作，增加现有的哈希桶数量，减少哈希冲突
开始默认使用 hash 表 1 保存键值对数据，哈希表 2 此刻没有分配空间。当数据越来多触发 rehash 操作，则执行以下操作：
- 给 hash 表 2 分配更大的空间；
- 将 hash 表 1 的数据重新映射拷贝到 hash 表 2 中；
- 释放 hash 表 1 的空间。

 值得注意的是，将 hash 表 1 的数据重新映射到 hash 表 2 的过程中并不是一次性的，这样会造成 Redis 阻塞，无法提供服务。
 而是采用了`渐进式 rehash`，每次处理客户端请求的时候，先从 hash 表 1 中第一个索引开始，将这个位置的 所有数据拷贝到 hash 表 2 中，就这样将 rehash 分散到多次请求过程中，避免耗时阻塞。

### Redis I/O多路复用模型
Redis 采用 I/O 多路复用技术，并发处理连接。采用了 epoll + 自己实现的简单的事件框架。epoll 中的读、写、关闭、连接都转化成了事件，然后利用 epoll 的多路复用特性，绝不在 IO 上浪费一点时间。


### Redis LRU淘汰策略

代码
``` java
class LRUCache<K, V> extends LinkedHashMap<K, V> {
        private final int SIZE;
        /**
        * 缓存数据大小
        */
        public LRUCache(int size) {
            super((int) Math.ceil(size / 0.75) + 1, 0.75f, true);
            SIZE = size;
        }

        @Override
        protected boolean removeEldestEntry(Map.Entry<K, V> eldest) {
            //到数据量就进行删除
            return size() > SIZE;
        }
}
```

### RedisCluster 设计成16384个槽
1. 16k(16384)槽位使用的空间在2kb,如果使用65k(65536)槽位占用空间在8kb,
占用空间：槽数/8 ; 16384/8 * 1024 = 2kb
2. redis 集群主节点数量不可能超过1000个，如果节点越多发送的心跳包的数据越多，也会导致网络拥堵，作者建议节点不超过1000个，所有16384槽足够用
3. 槽位越小，节点少的情况下，压缩率高  例如bitmap
4. CRC16算法产生hash值有16bit,2^16= 65536

### Redis 分片机制
使用虚拟哈希槽分区，所有的键根据哈希函数映射到 0 ~ 16383 整数槽内，每个key通过CRC16校验后对16384取模来决定放置哪个槽(Slot)，每一个节点负责维护一部分槽以及槽所映射的键值数据。
计算公式：slot = CRC16(key) & 16383。

使用哈希槽的好处就在于可以方便的添加或移除节点。

### Redis 虚拟分区特点
- 解耦数据和节点之间的关系，简化了节点扩容和收缩难度。
- 节点自身维护槽的映射关系，不需要客户端或者代理服务维护槽分区元数据
- 支持节点、槽和键之间的映射查询，用于数据路由，在线集群伸缩等场景。

## Redis 集群脑裂

### Redis 脑裂
所谓的脑裂，就是指在主从集群中，同时有两个主节点，它们都能接收写请求。而脑裂最直接的影响，就是客户端不知道应该往哪个主节点写入数据，结果就是不同的客户端会往不同的主节点上写入数据。而且，严重的话，脑裂会进一步导致数据丢失

### Redis 集群为什么会发生脑裂
#### 1.数据同步出现了问题
在主从集群中发生数据丢失，最常见的原因就是主库的数据还没有同步到从库，结果主库发生了故障，等从库升级为主库后，未同步的数据就丢失了。

如果是这种情况的数据丢失，我们可以通过比对主从库上的复制进度差值来进行判断，也就是计算 master_repl_offset 和 slave_repl_offset 的差值。如果从库上的 slave_repl_offset 小于原主库的 master_repl_offset，那么，我们就可以认定数据丢失是由数据同步未完成导致的。

#### 2.排查客户端的操作日志，发现脑裂现象
在排查客户端的操作日志时，我们发现，在主从切换后的一段时间内，有一个客户端仍然在和原主库通信，并没有和升级的新主库进行交互。这就相当于主从集群中同时有了两个主库。根据这个迹象，我们就想到了在分布式主从集群发生故障时会出现的一个问题：脑裂。


#### 3.发现是原主库假故障导致的脑裂
我们是采用哨兵机制进行主从切换的，当主从切换发生时，一定是有超过预设数量（quorum 配置项）的哨兵实例和主库的心跳都超时了，才会把主库判断为客观下线，然后，哨兵开始执行切换操作。哨兵切换完成后，客户端会和新主库进行通信，发送请求操作。


### 如何应对脑裂问题？
Redis 已经提供了两个配置项来限制主库的请求处理，分别是 min-slaves-to-write 和 min-slaves-max-lag。

- min-slaves-to-write：这个配置项设置了主库能进行数据同步的最少从库数量；
- min-slaves-max-lag：这个配置项设置了主从库间进行数据复制时，从库给主库发送 ACK 消息的最大延迟（以秒为单位）。

我们可以把 min-slaves-to-write 和 min-slaves-max-lag 这两个配置项搭配起来使用，分别给它们设置一定的阈值，假设为 N 和 T。这两个配置项组合后的要求是，主库连接的从库中至少有 N 个从库，和主库进行数据复制时的 ACK 消息延迟不能超过 T 秒，否则，主库就不会再接收客户端的请求了。


即使原主库是假故障，它在假故障期间也无法响应哨兵心跳，也不能和从库进行同步，自然也就无法和从库进行 ACK 确认了。这样一来，min-slaves-to-write 和 min-slaves-max-lag 的组合要求就无法得到满足，原主库就会被限制接收客户端请求，客户端也就不能在原主库中写入新数据了。

## Redis持久化？

### RDB持久化机制
优点：
1. 只有一个文件 dump.rdb，方便持久化。
2. 容灾性好，一个文件可以保存到安全的磁盘。
3. 性能最大化，fork 子进程来完成写操作，让主进程继续处理命令，所以是 IO 最大化。使用单独子进程来进行持久化，主进程不会进行任何 IO 操作，保证了 redis 的高性能
4. 相对于数据集大时，比 AOF 的启动效率更高。

缺点：
1. 数据安全性低。RDB 是间隔一段时间进行持久化，如果持久化之间 redis 发生故障，会发生数据丢失。所以这种方式更适合数据要求不严谨的时候)
2. AOF（Append-only file)持久化方式：是指所有的命令行记录以 redis 命令请 求协议的格式完全持久化存储)保存为 aof 文件

### AOF持久化机制
优点：
1. 数据安全，aof 持久化可以配置 appendfsync 属性，有 always，每进行一次 命令操作就记录到 aof 文件中一次。
2. 通过 append 模式写文件，即使中途服务器宕机，可以通过 redis-check-aof 工具解决数据一致性问题。
3. AOF 机制的 rewrite 模式。AOF 文件没被 rewrite 之前（文件过大时会对命令 进行合并重写），可以删除其中的某些命令（比如误操作的 flushall）)

缺点：
1. AOF 文件比 RDB 文件大，且恢复速度慢。
2. 数据集大的时候，比 rdb 启动效率低。

持久化优缺点是什么？
- AOF文件比RDB更新频率高，优先使用AOF还原数据。
- AOF比RDB更安全也更大
- RDB性能比AOF好
- 如果两个都配了优先加载AOF


### Redis的内存淘汰策略有哪些

- noeviction：当内存不足以容纳新写入数据时，新写入操作会报错。

- allkeys-lru：当内存不足以容纳新写入数据时，在键空间中，移除最近最少使用的key。（这个是最常用的）

- allkeys-random：当内存不足以容纳新写入数据时，在键空间中，随机移除某个key。
设置过期时间的键空间选择性移除

- volatile-lru：当内存不足以容纳新写入数据时，在设置了过期时间的键空间中，移除最近最少使用的key。

- volatile-random：当内存不足以容纳新写入数据时，在设置了过期时间的键空间中，随机移除某个key。

- volatile-ttl：当内存不足以容纳新写入数据时，在设置了过期时间的键空间中，有更早过期时间的key优先移除。

## Redis
### 高可用方案
1. Redis Sentinal 
2. 代理 + 分片 + 双副本 组合的集群，使用阿里云Redis集群版

### 分布式锁实现原理
Redisson redLock实现分布式锁
1. 加锁机制
2. 锁互斥
3. watch dog 自动延期机制
4. 可重入加锁
5. 锁释放

###  key设计问题
- key 加冒号:区分，可以根据业务模块划分
- key 越短越好
### 数据分片问题

### 常用操作命令
### 主从切换锁丢失问题
### 整个redis集群挂掉，业务服务应对方案（按redis作用讲）
### 批量命令（mget、mset相关）和不同数据类型如何批量修改值
mget 和 mset 只能使用string 类型
其余类型需要批量修改值，建议使用管道或者lua脚本 
### 生产禁用命令以及原因，scan、unlink命令考察
keys 禁用 ，单线程会阻塞
scan 增量扫描key
unlink 异步删除

### 单线程为什么快、吞吐高
###  跳表
跳跃表是有序集合的底层实现之一。

跳跃表是基于多指针有序链表实现的，可以看成多个有序链表。
跳跃表是一种随机化数据结构，查找、添加、删除操作都可以在对数期望时间下完成。
跳跃表目前在 Redis 的唯一作用，就是作为有序集类型的底层数据结构（之一，另一个构成有序集的结构是字典）。
与红黑树等平衡树相比，跳跃表具有以下优点：
> - 插入速度非常快速，因为不需要平衡树的旋转操作；
> - 更容易实现；
> - 支持无锁操作。