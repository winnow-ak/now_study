
- 数据主键id
> 优点：理解起来最容易，实现起来也最简单。
>
> 缺点：也非常明显了，每种数据库的实现不同，如果数据库需要迁移的话比较麻烦；最大的问题是性能问题，并发量到一定级别的时候这个方法估计会很难满足性能需求；另外通过数据库自增生成的 ID 携带的信息太少，只能起到一个标识的作用，同时自增 ID 也是连续的。
- uuid 
> **优点** ：本地生成，没有网络消耗，不需要第三方组件（也就没有单点的风险），生成比较简单，性能好。
>
> 缺点：长度长，不利于存储，并且没有排序，相对来说还会影响性能（比如 MySQL 的 InnoDB 引擎，如果 UUID 作为数据库主键，其无序性会导致数据位置频繁变动）

- 中间件 redis/zk/mongoDB
>Redis 利用 incr 和 increby ；MongoDB 的 ObjectId；zk 通过 znode 数据版本；都可以生成全局的唯一标识码。
>
>优点：性能高于数据库；可以使用集群部署；ID 内自带一些含义，比如时间戳；
>
>缺点：和数据库一样，需要引入对应的组件/软件，增加了系统的复杂度；最关键的是，这两种方案都意味着生成全局唯一 ID 的系统（服务），会成为一个单点，在软件架构中，单独就意味着风险；如果这个服务出现问题，那么所有依赖于这个服务的系统都会崩溃掉。
 

- Snowflake 雪花

> 优点：本地生成，没有网络消耗，不需要第三方组件（也就没有单点的风险），一定范围内唯一（基本可以满足大部分场景），性能好，按时间戳递增（趋势递增）；
>
> 缺点：依赖于机器时钟，同一台机器如果把时间回拨，生成的 ID 就会有重复的风险。

SnowFlake 算法生成 ID 是一个 64 bit 的整数，包括：
> 1 bit ：不使用，固定是 0 ；
>
> 41 bit ：时间戳（毫秒），数值范围是：0 至 2的41次方 - 1 ；转换成年的话，大约是 69 年；
> 
> 10 bit ：机器 ID ；5 位机房 ID + 5 位机器 ID ；（服务集群数量比较小的时候，可以手动配置，服务规模大的话，可以采用第三方组件进行自动配置，比如美团的 Leaf-snowflake，就是通过 Zookeeper 的持久顺序节点做为机器 ID）
>
> 12 bit ：序列号，用来记录同一个毫秒内生成的不同 ID 。
在Java中，SnowFlake 算法生成的 ID 正好可以用 long 来进行存储。